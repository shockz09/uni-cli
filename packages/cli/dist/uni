#!/usr/bin/env bun
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __require = import.meta.require;
// ../shared/src/errors.ts
class UniError extends Error {
  code;
  suggestion;
  constructor(message, code, suggestion) {
    super(message);
    this.code = code;
    this.suggestion = suggestion;
    this.name = "UniError";
  }
  toJSON() {
    return {
      error: this.message,
      code: this.code,
      suggestion: this.suggestion
    };
  }
}

class ServiceNotFoundError extends UniError {
  constructor(serviceName) {
    super(`Service '${serviceName}' not found`, "SERVICE_NOT_FOUND", `Run 'uni list' to see available services, or install with 'uni install ${serviceName}'`);
    this.name = "ServiceNotFoundError";
  }
}

class CommandNotFoundError extends UniError {
  constructor(serviceName, commandName, availableCommands) {
    const suggestions = availableCommands.length > 0 ? `Available commands: ${availableCommands.join(", ")}` : `Run 'uni ${serviceName} --help' for available commands`;
    super(`Command '${commandName}' not found in service '${serviceName}'`, "COMMAND_NOT_FOUND", suggestions);
    this.name = "CommandNotFoundError";
  }
}
class MissingArgumentError extends UniError {
  constructor(argName, command) {
    super(`Missing required argument: ${argName}`, "MISSING_ARGUMENT", `Usage: uni ${command} <${argName}>`);
    this.name = "MissingArgumentError";
  }
}

class InvalidOptionError extends UniError {
  constructor(optionName, value, expectedType) {
    super(`Invalid value for --${optionName}: '${value}'`, "INVALID_OPTION", `Expected ${expectedType}`);
    this.name = "InvalidOptionError";
  }
}
// ../shared/src/helpers.ts
function isTTY() {
  return process.stdout.isTTY ?? false;
}
function supportsColor() {
  if (process.env.NO_COLOR !== undefined)
    return false;
  if (process.env.FORCE_COLOR !== undefined)
    return true;
  if (process.env.CLICOLOR === "0")
    return false;
  return isTTY();
}
function truncate(str, maxLength) {
  if (str.length <= maxLength)
    return str;
  return str.slice(0, maxLength - 3) + "...";
}
function padRight(str, length) {
  if (str.length >= length)
    return str;
  return str + " ".repeat(length - str.length);
}
function deepMerge(target, ...sources) {
  const result = { ...target };
  for (const source of sources) {
    for (const key in source) {
      const sourceValue = source[key];
      const targetValue = result[key];
      if (sourceValue !== null && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue !== null && typeof targetValue === "object" && !Array.isArray(targetValue)) {
        result[key] = deepMerge(targetValue, sourceValue);
      } else if (sourceValue !== undefined) {
        result[key] = sourceValue;
      }
    }
  }
  return result;
}
// src/core/parser.ts
var GLOBAL_OPTIONS = [
  { name: "help", short: "h", type: "boolean", description: "Show help" },
  { name: "version", short: "v", type: "boolean", description: "Show version" },
  { name: "json", type: "boolean", description: "Output as JSON" },
  { name: "verbose", type: "boolean", description: "Verbose output" },
  { name: "quiet", short: "q", type: "boolean", description: "Suppress output" },
  { name: "config", short: "c", type: "string", description: "Config file path" }
];
function parseArgs(argv) {
  const result = {
    globalFlags: {
      json: false,
      verbose: false,
      quiet: false
    },
    service: null,
    command: null,
    subcommand: null,
    flags: {},
    args: [],
    raw: argv
  };
  let i = 0;
  let parsingGlobal = true;
  while (i < argv.length) {
    const arg = argv[i];
    if (arg.startsWith("--")) {
      const flagName = arg.slice(2);
      const [name, value] = flagName.includes("=") ? flagName.split("=", 2) : [flagName, undefined];
      const globalOpt = GLOBAL_OPTIONS.find((o) => o.name === name);
      if (globalOpt && parsingGlobal) {
        if (globalOpt.type === "boolean") {
          result.globalFlags[name] = true;
        } else {
          result.globalFlags[name] = value ?? argv[++i];
        }
      } else {
        if (value !== undefined) {
          result.flags[name] = value;
        } else {
          const nextArg = argv[i + 1];
          if (nextArg && !nextArg.startsWith("-")) {
            result.flags[name] = nextArg;
            i++;
          } else {
            result.flags[name] = true;
          }
        }
      }
    } else if (arg.startsWith("-") && arg.length === 2) {
      const shortFlag = arg.slice(1);
      const globalOpt = GLOBAL_OPTIONS.find((o) => o.short === shortFlag);
      if (globalOpt && parsingGlobal) {
        if (globalOpt.type === "boolean") {
          result.globalFlags[globalOpt.name] = true;
        } else {
          result.globalFlags[globalOpt.name] = argv[++i];
        }
      } else {
        result.flags[shortFlag] = true;
      }
    } else {
      parsingGlobal = false;
      if (!result.service) {
        result.service = arg;
      } else if (!result.command) {
        result.command = arg;
      } else if (!result.subcommand) {
        result.subcommand = arg;
      } else {
        result.args.push(arg);
      }
    }
    i++;
  }
  return result;
}
function parseCommandArgs(args, flags, argDefs = [], optionDefs = []) {
  const parsedArgs = {};
  const parsedFlags = {};
  for (let i = 0;i < argDefs.length; i++) {
    const def = argDefs[i];
    const value = args[i];
    if (value !== undefined) {
      parsedArgs[def.name] = value;
    } else if (def.required) {
      throw new MissingArgumentError(def.name, "command");
    } else if (def.default !== undefined) {
      parsedArgs[def.name] = def.default;
    }
  }
  for (const def of optionDefs) {
    const value = flags[def.name] ?? flags[def.short ?? ""];
    if (value !== undefined) {
      if (def.type === "number" && typeof value === "string") {
        const num = Number(value);
        if (isNaN(num)) {
          throw new InvalidOptionError(def.name, String(value), "number");
        }
        parsedFlags[def.name] = num;
      } else if (def.type === "boolean") {
        parsedFlags[def.name] = value === true || value === "true";
      } else {
        parsedFlags[def.name] = value;
      }
      if (def.choices && typeof parsedFlags[def.name] === "string") {
        if (!def.choices.includes(parsedFlags[def.name])) {
          throw new InvalidOptionError(def.name, String(parsedFlags[def.name]), `one of: ${def.choices.join(", ")}`);
        }
      }
    } else if (def.required) {
      throw new MissingArgumentError(`--${def.name}`, "command");
    } else if (def.default !== undefined) {
      parsedFlags[def.name] = def.default;
    }
  }
  for (const [key, value] of Object.entries(flags)) {
    if (!(key in parsedFlags)) {
      parsedFlags[key] = value;
    }
  }
  return { args: parsedArgs, flags: parsedFlags };
}

// src/core/registry.ts
import * as path from "path";
import * as fs from "fs";
import { execSync } from "child_process";
var PLUGINS_DIR = path.join(process.env.HOME || "~", ".uni/plugins");
var UNI_DIR = path.join(process.env.HOME || "~", ".uni");

class ServiceRegistry {
  services = new Map;
  loadedServices = new Map;
  discovered = false;
  async discover() {
    if (this.discovered) {
      return Array.from(this.services.values());
    }
    this.services.clear();
    await this.discoverBuiltin();
    await this.discoverNpm();
    await this.discoverPlugins();
    this.discovered = true;
    return Array.from(this.services.values());
  }
  async getMetadata(name) {
    if (!this.discovered) {
      await this.discover();
    }
    return this.services.get(name);
  }
  async load(name) {
    const cached = this.loadedServices.get(name);
    if (cached)
      return cached;
    const metadata = await this.getMetadata(name);
    if (!metadata) {
      throw new ServiceNotFoundError(name);
    }
    try {
      const module = await import(metadata.path);
      const service = module.default || module.service || module;
      if (!service.name || !service.commands) {
        throw new Error(`Invalid service module: ${metadata.path}`);
      }
      if (service.setup) {
        await service.setup();
      }
      this.loadedServices.set(name, service);
      return service;
    } catch (error) {
      throw new Error(`Failed to load service '${name}': ${error}`);
    }
  }
  async list() {
    return this.discover();
  }
  async has(name) {
    if (!this.discovered) {
      await this.discover();
    }
    return this.services.has(name);
  }
  invalidate() {
    this.discovered = false;
    this.services.clear();
    this.loadedServices.clear();
  }
  async discoverBuiltin() {
    const currentDir = import.meta.dir;
    const isInDist = currentDir.includes("/dist");
    const packagesDir = isInDist ? path.join(currentDir, "../../") : path.join(currentDir, "../../../");
    try {
      const entries = fs.readdirSync(packagesDir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory() && entry.name.startsWith("service-")) {
          const serviceName = entry.name.replace("service-", "");
          const servicePath = path.join(packagesDir, entry.name, "src/index.ts");
          if (fs.existsSync(servicePath)) {
            try {
              const pkgPath = path.join(packagesDir, entry.name, "package.json");
              const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
              this.services.set(serviceName, {
                name: serviceName,
                version: pkg.version || "0.0.0",
                description: pkg.description || `${serviceName} service`,
                source: "builtin",
                path: servicePath,
                authRequired: false,
                commands: []
              });
            } catch {
              this.services.set(serviceName, {
                name: serviceName,
                version: "0.0.0",
                description: `${serviceName} service`,
                source: "builtin",
                path: servicePath,
                authRequired: false,
                commands: []
              });
            }
          }
        }
      }
    } catch {}
  }
  async discoverNpm() {
    const nodeModulesDir = path.join(process.cwd(), "node_modules");
    if (!fs.existsSync(nodeModulesDir)) {
      return;
    }
    try {
      const uniScopeDir = path.join(nodeModulesDir, "@uni");
      if (fs.existsSync(uniScopeDir)) {
        const entries = fs.readdirSync(uniScopeDir, { withFileTypes: true });
        for (const entry of entries) {
          if (entry.isDirectory() && entry.name.startsWith("service-")) {
            await this.addNpmService(path.join(uniScopeDir, entry.name), `@uni/${entry.name}`);
          }
        }
      }
      const topLevelEntries = fs.readdirSync(nodeModulesDir, { withFileTypes: true });
      for (const entry of topLevelEntries) {
        if (entry.isDirectory() && entry.name.startsWith("uni-service-")) {
          await this.addNpmService(path.join(nodeModulesDir, entry.name), entry.name);
        }
      }
      for (const entry of topLevelEntries) {
        if (entry.isDirectory() && entry.name.startsWith("@") && entry.name !== "@uni") {
          const scopeDir = path.join(nodeModulesDir, entry.name);
          try {
            const scopeEntries = fs.readdirSync(scopeDir, { withFileTypes: true });
            for (const scopeEntry of scopeEntries) {
              if (scopeEntry.isDirectory()) {
                const pkgPath = path.join(scopeDir, scopeEntry.name, "package.json");
                if (fs.existsSync(pkgPath)) {
                  const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
                  if (pkg.keywords?.includes("uni-service")) {
                    await this.addNpmService(path.join(scopeDir, scopeEntry.name), `${entry.name}/${scopeEntry.name}`);
                  }
                }
              }
            }
          } catch {}
        }
      }
    } catch {}
  }
  async addNpmService(pkgDir, pkgName) {
    try {
      const pkgPath = path.join(pkgDir, "package.json");
      if (!fs.existsSync(pkgPath))
        return;
      const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
      let serviceName = pkgName;
      if (serviceName.startsWith("@uni/service-")) {
        serviceName = serviceName.replace("@uni/service-", "");
      } else if (serviceName.startsWith("uni-service-")) {
        serviceName = serviceName.replace("uni-service-", "");
      } else if (serviceName.includes("/")) {
        const parts = serviceName.split("/");
        serviceName = parts[1].replace("uni-service-", "").replace("uni-", "");
      }
      const mainFile = pkg.main || "dist/index.js";
      const entryPath = path.join(pkgDir, mainFile);
      if (!fs.existsSync(entryPath)) {
        return;
      }
      this.services.set(serviceName, {
        name: serviceName,
        version: pkg.version || "0.0.0",
        description: pkg.description || `${serviceName} service`,
        source: "npm",
        path: entryPath,
        authRequired: false,
        commands: []
      });
    } catch {}
  }
  async discoverPlugins() {
    try {
      if (!fs.existsSync(PLUGINS_DIR)) {
        return;
      }
      const entries = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true });
      for (const entry of entries) {
        try {
          if (entry.isFile() && entry.name.endsWith(".ts")) {
            const serviceName = entry.name.replace(".ts", "");
            const servicePath = path.join(PLUGINS_DIR, entry.name);
            this.services.set(serviceName, {
              name: serviceName,
              version: "0.0.0",
              description: `${serviceName} plugin`,
              source: "plugin",
              path: servicePath,
              authRequired: false,
              commands: []
            });
          } else if (entry.isDirectory()) {
            const indexPath = path.join(PLUGINS_DIR, entry.name, "index.ts");
            if (fs.existsSync(indexPath)) {
              const serviceName = entry.name;
              let description = `${serviceName} plugin`;
              let version = "0.0.0";
              const pkgPath = path.join(PLUGINS_DIR, entry.name, "package.json");
              if (fs.existsSync(pkgPath)) {
                try {
                  const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
                  description = pkg.description || description;
                  version = pkg.version || version;
                } catch {}
              }
              this.services.set(serviceName, {
                name: serviceName,
                version,
                description,
                source: "plugin",
                path: indexPath,
                authRequired: false,
                commands: []
              });
            }
          }
        } catch {
          console.warn(`Warning: Failed to load plugin '${entry.name}'`);
        }
      }
    } catch {}
  }
  async ensurePluginEnvironment() {
    const pkgPath = path.join(UNI_DIR, "package.json");
    if (!fs.existsSync(UNI_DIR)) {
      fs.mkdirSync(UNI_DIR, { recursive: true });
    }
    if (!fs.existsSync(PLUGINS_DIR)) {
      fs.mkdirSync(PLUGINS_DIR, { recursive: true });
    }
    if (!fs.existsSync(pkgPath)) {
      const pkg = {
        name: "uni-plugins",
        private: true,
        type: "module",
        dependencies: {
          "@uni/shared": "^0.1.0"
        }
      };
      fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
      try {
        execSync("bun install", {
          cwd: UNI_DIR,
          stdio: "pipe"
        });
      } catch {
        try {
          execSync("npm install", {
            cwd: UNI_DIR,
            stdio: "pipe"
          });
        } catch {
          console.warn("Warning: Could not install @uni/shared for plugin types");
        }
      }
    }
  }
}
var registry = new ServiceRegistry;

// src/core/config.ts
import * as path2 from "path";
import * as fs2 from "fs";
var GLOBAL_CONFIG_DIR = path2.join(process.env.HOME || "~", ".uni");
var GLOBAL_CONFIG_PATH = path2.join(GLOBAL_CONFIG_DIR, "config.toml");
var PROJECT_CONFIG_PATH = ".uni/config.toml";
var DEFAULT_CONFIG = {
  version: "1.0",
  global: {
    defaultOutput: "human",
    color: true
  },
  services: {},
  aliases: {},
  ask: {
    confirm: true
  },
  flows: {}
};

class ConfigManager {
  config = null;
  configPath = null;
  async load(customPath) {
    if (this.config && !customPath) {
      return this.config;
    }
    let config = { ...DEFAULT_CONFIG };
    const globalConfig = await this.loadFile(GLOBAL_CONFIG_PATH);
    if (globalConfig) {
      config = deepMerge(config, globalConfig);
      this.configPath = GLOBAL_CONFIG_PATH;
    }
    const projectConfigPath = path2.join(process.cwd(), PROJECT_CONFIG_PATH);
    const projectConfig = await this.loadFile(projectConfigPath);
    if (projectConfig) {
      config = deepMerge(config, projectConfig);
      this.configPath = projectConfigPath;
    }
    if (customPath) {
      const customConfig = await this.loadFile(customPath);
      if (customConfig) {
        config = deepMerge(config, customConfig);
        this.configPath = customPath;
      }
    }
    config = this.applyEnvOverrides(config);
    this.config = config;
    return config;
  }
  getGlobal() {
    return this.config?.global ?? DEFAULT_CONFIG.global;
  }
  getService(serviceName) {
    return this.config?.services?.[serviceName] ?? {};
  }
  getPath() {
    return this.configPath;
  }
  getConfigDir() {
    return GLOBAL_CONFIG_DIR;
  }
  getGlobalConfigPath() {
    return GLOBAL_CONFIG_PATH;
  }
  get(key) {
    if (!this.config)
      return;
    const parts = key.split(".");
    let obj = this.config;
    for (const part of parts) {
      if (obj && typeof obj === "object" && part in obj) {
        obj = obj[part];
      } else {
        return;
      }
    }
    return obj;
  }
  getAliases() {
    return this.config?.aliases ?? {};
  }
  getAlias(name) {
    return this.config?.aliases?.[name];
  }
  async setAlias(name, command) {
    await this.ensureConfigDir();
    const configData = await this.loadFile(GLOBAL_CONFIG_PATH) || { ...DEFAULT_CONFIG };
    if (!configData.aliases) {
      configData.aliases = {};
    }
    configData.aliases[name] = command;
    await this.saveFile(GLOBAL_CONFIG_PATH, configData);
    this.config = null;
    await this.load();
  }
  async removeAlias(name) {
    await this.ensureConfigDir();
    const configData = await this.loadFile(GLOBAL_CONFIG_PATH) || { ...DEFAULT_CONFIG };
    if (!configData.aliases || !(name in configData.aliases)) {
      return false;
    }
    delete configData.aliases[name];
    await this.saveFile(GLOBAL_CONFIG_PATH, configData);
    this.config = null;
    await this.load();
    return true;
  }
  getFlows() {
    return this.config?.flows ?? {};
  }
  getFlow(name) {
    return this.config?.flows?.[name];
  }
  async setFlow(name, commands) {
    await this.ensureConfigDir();
    const configData = await this.loadFile(GLOBAL_CONFIG_PATH) || { ...DEFAULT_CONFIG };
    if (!configData.flows) {
      configData.flows = {};
    }
    configData.flows[name] = commands;
    await this.saveFile(GLOBAL_CONFIG_PATH, configData);
    this.config = null;
    await this.load();
  }
  async removeFlow(name) {
    await this.ensureConfigDir();
    const configData = await this.loadFile(GLOBAL_CONFIG_PATH) || { ...DEFAULT_CONFIG };
    if (!configData.flows || !(name in configData.flows)) {
      return false;
    }
    delete configData.flows[name];
    await this.saveFile(GLOBAL_CONFIG_PATH, configData);
    this.config = null;
    await this.load();
    return true;
  }
  getFullConfig() {
    return this.config;
  }
  getAsk() {
    return this.config?.ask ?? { confirm: true };
  }
  async ensureConfigDir() {
    if (!fs2.existsSync(GLOBAL_CONFIG_DIR)) {
      fs2.mkdirSync(GLOBAL_CONFIG_DIR, { recursive: true });
    }
  }
  async set(key, value) {
    await this.ensureConfigDir();
    const config = await this.loadFile(GLOBAL_CONFIG_PATH) || { ...DEFAULT_CONFIG };
    const parts = key.split(".");
    let obj = config;
    for (let i = 0;i < parts.length - 1; i++) {
      if (!obj[parts[i]]) {
        obj[parts[i]] = {};
      }
      obj = obj[parts[i]];
    }
    obj[parts[parts.length - 1]] = value;
    await this.saveFile(GLOBAL_CONFIG_PATH, config);
    this.config = null;
    await this.load();
  }
  async loadFile(filePath) {
    try {
      if (!fs2.existsSync(filePath)) {
        return null;
      }
      const content = fs2.readFileSync(filePath, "utf-8");
      return this.parseToml(content);
    } catch {
      return null;
    }
  }
  async saveFile(filePath, config) {
    const content = this.stringifyToml(config);
    fs2.writeFileSync(filePath, content, "utf-8");
  }
  parseToml(content) {
    const config = { ...DEFAULT_CONFIG, aliases: {}, ask: { confirm: true }, flows: {} };
    let currentSection = "";
    for (const line of content.split(`
`)) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const sectionMatch = trimmed.match(/^\[(.+)\]$/);
      if (sectionMatch) {
        currentSection = sectionMatch[1];
        continue;
      }
      const kvMatch = trimmed.match(/^([\w-]+)\s*=\s*(.+)$/);
      if (kvMatch) {
        const [, key, rawValue] = kvMatch;
        const value = this.parseTomlValue(rawValue);
        if (currentSection === "global") {
          config.global[key] = value;
        } else if (currentSection === "aliases") {
          config.aliases[key] = String(value);
        } else if (currentSection === "ask") {
          config.ask[key] = value;
        } else if (currentSection === "flows") {
          config.flows[key] = Array.isArray(value) ? value : [String(value)];
        } else if (currentSection.startsWith("services.")) {
          const serviceName = currentSection.replace("services.", "");
          if (!config.services[serviceName]) {
            config.services[serviceName] = {};
          }
          config.services[serviceName][key] = value;
        }
      }
    }
    return config;
  }
  parseTomlValue(raw) {
    const trimmed = raw.trim();
    if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
      const inner = trimmed.slice(1, -1);
      if (!inner.trim())
        return [];
      const elements = [];
      let current = "";
      let inQuotes = false;
      let quoteChar = "";
      for (const char of inner) {
        if ((char === '"' || char === "'") && !inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar && inQuotes) {
          inQuotes = false;
          quoteChar = "";
        } else if (char === "," && !inQuotes) {
          if (current.trim()) {
            elements.push(current.trim());
          }
          current = "";
        } else {
          current += char;
        }
      }
      if (current.trim()) {
        elements.push(current.trim());
      }
      return elements;
    }
    if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
      return trimmed.slice(1, -1);
    }
    if (trimmed === "true")
      return true;
    if (trimmed === "false")
      return false;
    const num = Number(trimmed);
    if (!isNaN(num))
      return num;
    return trimmed;
  }
  stringifyToml(config) {
    const lines = [];
    if (config.version) {
      lines.push(`version = "${config.version}"`);
      lines.push("");
    }
    if (config.global) {
      lines.push("[global]");
      for (const [key, value] of Object.entries(config.global)) {
        lines.push(`${key} = ${this.tomlValue(value)}`);
      }
      lines.push("");
    }
    if (config.services) {
      for (const [serviceName, serviceConfig] of Object.entries(config.services)) {
        if (Object.keys(serviceConfig).length > 0) {
          lines.push(`[services.${serviceName}]`);
          for (const [key, value] of Object.entries(serviceConfig)) {
            lines.push(`${key} = ${this.tomlValue(value)}`);
          }
          lines.push("");
        }
      }
    }
    if (config.aliases && Object.keys(config.aliases).length > 0) {
      lines.push("[aliases]");
      for (const [name, command] of Object.entries(config.aliases)) {
        lines.push(`${name} = ${this.tomlValue(command)}`);
      }
      lines.push("");
    }
    if (config.ask && Object.keys(config.ask).length > 0) {
      lines.push("[ask]");
      for (const [key, value] of Object.entries(config.ask)) {
        lines.push(`${key} = ${this.tomlValue(value)}`);
      }
      lines.push("");
    }
    if (config.flows && Object.keys(config.flows).length > 0) {
      lines.push("[flows]");
      for (const [name, commands] of Object.entries(config.flows)) {
        lines.push(`${name} = ${this.tomlValue(commands)}`);
      }
      lines.push("");
    }
    return lines.join(`
`);
  }
  tomlValue(value) {
    if (Array.isArray(value)) {
      const items = value.map((v) => `"${v}"`).join(", ");
      return `[${items}]`;
    }
    if (typeof value === "string")
      return `"${value}"`;
    if (typeof value === "boolean")
      return value.toString();
    if (typeof value === "number")
      return value.toString();
    return String(value);
  }
  applyEnvOverrides(config) {
    if (process.env.UNI_OUTPUT) {
      config.global.defaultOutput = process.env.UNI_OUTPUT;
    }
    if (process.env.UNI_COLOR !== undefined) {
      config.global.color = process.env.UNI_COLOR !== "false" && process.env.UNI_COLOR !== "0";
    }
    return config;
  }
}
var config = new ConfigManager;

// src/core/history.ts
import * as path3 from "path";
import * as fs3 from "fs";
var HISTORY_DIR = path3.join(process.env.HOME || "~", ".uni");
var HISTORY_PATH = path3.join(HISTORY_DIR, "history.json");
var MAX_HISTORY = 1000;

class HistoryManager {
  store = null;
  async load() {
    if (this.store) {
      return this.store;
    }
    try {
      if (fs3.existsSync(HISTORY_PATH)) {
        const content = fs3.readFileSync(HISTORY_PATH, "utf-8");
        this.store = JSON.parse(content);
      } else {
        this.store = { commands: [] };
      }
    } catch {
      this.store = { commands: [] };
    }
    return this.store;
  }
  async addCommand(cmd, exitCode) {
    await this.ensureDir();
    const store = await this.load();
    const maxId = store.commands.reduce((max, c) => Math.max(max, c.id), 0);
    const entry = {
      id: maxId + 1,
      cmd,
      time: new Date().toISOString(),
      exit: exitCode
    };
    store.commands.push(entry);
    if (store.commands.length > MAX_HISTORY) {
      store.commands = store.commands.slice(-MAX_HISTORY);
    }
    await this.save();
  }
  async getHistory(options = {}) {
    const store = await this.load();
    let entries = [...store.commands].reverse();
    if (options.search) {
      const searchLower = options.search.toLowerCase();
      entries = entries.filter((e) => e.cmd.toLowerCase().includes(searchLower));
    }
    if (options.offset && options.offset > 0) {
      entries = entries.slice(options.offset);
    }
    if (options.limit && options.limit > 0) {
      entries = entries.slice(0, options.limit);
    }
    return entries;
  }
  async getCommand(id) {
    const store = await this.load();
    return store.commands.find((c) => c.id === id) || null;
  }
  async clearHistory() {
    this.store = { commands: [] };
    await this.save();
  }
  getPath() {
    return HISTORY_PATH;
  }
  async ensureDir() {
    if (!fs3.existsSync(HISTORY_DIR)) {
      fs3.mkdirSync(HISTORY_DIR, { recursive: true });
    }
  }
  async save() {
    if (!this.store)
      return;
    await this.ensureDir();
    fs3.writeFileSync(HISTORY_PATH, JSON.stringify(this.store, null, 2), "utf-8");
  }
}
var history = new HistoryManager;

// src/utils/colors.ts
var enabled = supportsColor();
var codes = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  dim: "\x1B[2m",
  italic: "\x1B[3m",
  underline: "\x1B[4m",
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  gray: "\x1B[90m",
  brightRed: "\x1B[91m",
  brightGreen: "\x1B[92m",
  brightYellow: "\x1B[93m",
  brightBlue: "\x1B[94m",
  brightMagenta: "\x1B[95m",
  brightCyan: "\x1B[96m",
  brightWhite: "\x1B[97m",
  bgRed: "\x1B[41m",
  bgGreen: "\x1B[42m",
  bgYellow: "\x1B[43m",
  bgBlue: "\x1B[44m"
};
function wrap(code, text) {
  if (!enabled)
    return text;
  return `${code}${text}${codes.reset}`;
}
var bold = (text) => wrap(codes.bold, text);
var dim = (text) => wrap(codes.dim, text);
var red = (text) => wrap(codes.red, text);
var green = (text) => wrap(codes.green, text);
var yellow = (text) => wrap(codes.yellow, text);
var cyan = (text) => wrap(codes.cyan, text);
var success = (text) => wrap(codes.green, text);
var error = (text) => wrap(codes.red, text);
var warning = (text) => wrap(codes.yellow, text);
var info = (text) => wrap(codes.cyan, text);
var muted = (text) => wrap(codes.gray, text);
var symbols = {
  success: enabled ? "\u2714" : "[OK]",
  error: enabled ? "\u2716" : "[ERROR]",
  warning: enabled ? "\u26A0" : "[WARN]",
  info: enabled ? "\u2139" : "[INFO]",
  arrow: enabled ? "\u2192" : "->",
  bullet: enabled ? "\u2022" : "-",
  pointer: enabled ? "\u276F" : ">"
};
function stripAnsi(str) {
  return str.replace(/\x1b\[[0-9;]*m/g, "");
}
function visibleLength(str) {
  return stripAnsi(str).length;
}

// src/core/flow.ts
function substituteArgs(commands, args) {
  return commands.map((cmd) => {
    let result = cmd;
    for (let i = 0;i < args.length; i++) {
      const placeholder = `$${i + 1}`;
      result = result.replace(new RegExp(`\\$${i + 1}`, "g"), args[i]);
    }
    return result;
  });
}
async function executeCommand(command) {
  const start = Date.now();
  try {
    const { spawn } = await import("child_process");
    const path4 = await import("path");
    const uniPath = path4.join(process.cwd(), "packages/cli/src/main.ts");
    return new Promise((resolve) => {
      const child = spawn("bun", ["run", uniPath, ...command.split(/\s+/)], {
        stdio: "pipe",
        cwd: process.cwd()
      });
      let stdout = "";
      let stderr = "";
      child.stdout?.on("data", (data) => {
        stdout += data.toString();
        process.stdout.write(data);
      });
      child.stderr?.on("data", (data) => {
        stderr += data.toString();
        process.stderr.write(data);
      });
      child.on("close", (code) => {
        resolve({
          command,
          success: code === 0,
          error: code !== 0 ? stderr || `Exit code ${code}` : undefined,
          duration: Date.now() - start
        });
      });
      child.on("error", (err) => {
        resolve({
          command,
          success: false,
          error: err.message,
          duration: Date.now() - start
        });
      });
    });
  } catch (error2) {
    return {
      command,
      success: false,
      error: error2 instanceof Error ? error2.message : String(error2),
      duration: Date.now() - start
    };
  }
}
async function runSequential(commands, options = {}) {
  const results = [];
  for (const command of commands) {
    if (options.dryRun) {
      console.log(`${dim("\u2192")} ${command}`);
      results.push({ command, success: true, duration: 0 });
    } else {
      console.log(`
${dim("\u2500")} ${cyan(command)}`);
      const result = await executeCommand(command);
      results.push(result);
      if (!result.success) {
        break;
      }
    }
  }
  return results;
}
async function runParallel(commands, options = {}) {
  if (options.dryRun) {
    for (const command of commands) {
      console.log(`${dim("\u2192")} ${command}`);
    }
    return commands.map((command) => ({ command, success: true, duration: 0 }));
  }
  const promises = commands.map(async (command) => {
    console.log(`
${dim("\u2500")} ${cyan(command)}`);
    return executeCommand(command);
  });
  return Promise.all(promises);
}
async function runCommands(commands, options = {}) {
  const start = Date.now();
  const count = commands.length;
  if (!options.dryRun) {
    console.log(`${dim("\u27F3")} Running ${count} command${count === 1 ? "" : "s"}...`);
  }
  const results = options.parallel ? await runParallel(commands, options) : await runSequential(commands, options);
  const totalDuration = Date.now() - start;
  const allSuccess = results.every((r) => r.success);
  if (!options.dryRun) {
    console.log("");
    if (allSuccess) {
      console.log(`${green("\u2713")} Done (${(totalDuration / 1000).toFixed(1)}s)`);
    } else {
      const failed = results.filter((r) => !r.success).length;
      console.log(`${red("\u2717")} ${failed} command${failed === 1 ? "" : "s"} failed`);
    }
  }
  return results;
}

class FlowManager {
  getFlows() {
    return config.getFlows();
  }
  getFlow(name) {
    return config.getFlow(name);
  }
  async addFlow(name, commands) {
    await config.setFlow(name, commands);
  }
  async removeFlow(name) {
    return config.removeFlow(name);
  }
  async runFlow(name, args, options = {}) {
    const commands = this.getFlow(name);
    if (!commands) {
      throw new Error(`Flow not found: ${name}`);
    }
    const substituted = substituteArgs(commands, args);
    return runCommands(substituted, options);
  }
  hasFlow(name) {
    return !!this.getFlow(name);
  }
}
var flow = new FlowManager;

// src/core/llm.ts
var DEFAULT_MODELS = {
  anthropic: "claude-3-haiku-20240307",
  openai: "gpt-4o-mini",
  ollama: "llama3.2",
  groq: "llama-3.1-8b-instant"
};
function createLLMClient(config2 = {}) {
  const provider = config2.provider || detectProvider();
  if (!provider) {
    throw new Error(`No LLM provider configured. Set one of:
` + `  - ANTHROPIC_API_KEY
` + `  - OPENAI_API_KEY
` + `  - GROQ_API_KEY
` + "  - Or run Ollama locally");
  }
  const model = config2.model || DEFAULT_MODELS[provider];
  switch (provider) {
    case "anthropic":
      return new AnthropicClient(config2.apiKey || process.env.ANTHROPIC_API_KEY, model);
    case "openai":
      return new OpenAIClient(config2.apiKey || process.env.OPENAI_API_KEY, model);
    case "ollama":
      return new OllamaClient(config2.baseUrl || "http://localhost:11434", model);
    case "groq":
      return new GroqClient(config2.apiKey || process.env.GROQ_API_KEY, model);
    default:
      throw new Error(`Unknown LLM provider: ${provider}`);
  }
}
function detectProvider() {
  if (process.env.ANTHROPIC_API_KEY)
    return "anthropic";
  if (process.env.OPENAI_API_KEY)
    return "openai";
  if (process.env.GROQ_API_KEY)
    return "groq";
  return null;
}

class AnthropicClient {
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model;
  }
  async complete(prompt, systemPrompt) {
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: 1024,
        system: systemPrompt,
        messages: [{ role: "user", content: prompt }]
      })
    });
    if (!response.ok) {
      const error2 = await response.text();
      throw new Error(`Anthropic API error: ${error2}`);
    }
    const data = await response.json();
    return data.content[0]?.text || "";
  }
}

class OpenAIClient {
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model;
  }
  async complete(prompt, systemPrompt) {
    const messages = [];
    if (systemPrompt) {
      messages.push({ role: "system", content: systemPrompt });
    }
    messages.push({ role: "user", content: prompt });
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: this.model,
        messages,
        max_tokens: 1024
      })
    });
    if (!response.ok) {
      const error2 = await response.text();
      throw new Error(`OpenAI API error: ${error2}`);
    }
    const data = await response.json();
    return data.choices[0]?.message?.content || "";
  }
}

class OllamaClient {
  baseUrl;
  model;
  constructor(baseUrl, model) {
    this.baseUrl = baseUrl;
    this.model = model;
  }
  async complete(prompt, systemPrompt) {
    const fullPrompt = systemPrompt ? `${systemPrompt}

User: ${prompt}` : prompt;
    const response = await fetch(`${this.baseUrl}/api/generate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.model,
        prompt: fullPrompt,
        stream: false
      })
    });
    if (!response.ok) {
      const error2 = await response.text();
      throw new Error(`Ollama error: ${error2}`);
    }
    const data = await response.json();
    return data.response || "";
  }
}

class GroqClient {
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model;
  }
  async complete(prompt, systemPrompt) {
    const messages = [];
    if (systemPrompt) {
      messages.push({ role: "system", content: systemPrompt });
    }
    messages.push({ role: "user", content: prompt });
    const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: this.model,
        messages,
        max_tokens: 1024
      })
    });
    if (!response.ok) {
      const error2 = await response.text();
      throw new Error(`Groq API error: ${error2}`);
    }
    const data = await response.json();
    return data.choices[0]?.message?.content || "";
  }
}

// src/core/output.ts
function createOutputFormatter(flags) {
  const forceJson = flags.json || !isTTY();
  const verbose = flags.verbose;
  const quiet = flags.quiet;
  return {
    json(data) {
      console.log(JSON.stringify(data, null, 2));
    },
    table(data, columns) {
      if (forceJson) {
        console.log(JSON.stringify(data, null, 2));
        return;
      }
      if (data.length === 0) {
        console.log(muted("No results"));
        return;
      }
      const cols = columns || Object.keys(data[0]);
      const widths = {};
      for (const col of cols) {
        widths[col] = col.length;
        for (const row of data) {
          const value = String(row[col] ?? "");
          widths[col] = Math.max(widths[col], visibleLength(value));
        }
        widths[col] = Math.min(widths[col], 50);
      }
      const header = cols.map((col) => bold(padRight(col.toUpperCase(), widths[col]))).join("  ");
      console.log(header);
      console.log(muted("\u2500".repeat(visibleLength(header))));
      for (const row of data) {
        const line = cols.map((col) => {
          const value = truncate(String(row[col] ?? ""), widths[col]);
          return padRight(value, widths[col]);
        }).join("  ");
        console.log(line);
      }
    },
    text(str) {
      if (!quiet) {
        console.log(str);
      }
    },
    list(items) {
      if (forceJson) {
        console.log(JSON.stringify(items, null, 2));
        return;
      }
      for (const item of items) {
        console.log(`  ${symbols.bullet} ${item}`);
      }
    },
    success(msg) {
      if (forceJson) {
        console.log(JSON.stringify({ status: "success", message: msg }));
        return;
      }
      if (!quiet) {
        console.log(`${success(symbols.success)} ${msg}`);
      }
    },
    error(msg) {
      if (forceJson) {
        console.error(JSON.stringify({ status: "error", message: msg }));
        return;
      }
      console.error(`${error(symbols.error)} ${error(msg)}`);
    },
    warn(msg) {
      if (forceJson) {
        console.log(JSON.stringify({ status: "warning", message: msg }));
        return;
      }
      if (!quiet) {
        console.log(`${warning(symbols.warning)} ${warning(msg)}`);
      }
    },
    info(msg) {
      if (forceJson) {
        console.log(JSON.stringify({ status: "info", message: msg }));
        return;
      }
      if (!quiet) {
        console.log(`${info(symbols.info)} ${msg}`);
      }
    },
    debug(msg) {
      if (verbose && !quiet) {
        console.log(`${muted("[debug]")} ${muted(msg)}`);
      }
    },
    spinner(msg) {
      if (!isTTY() || forceJson || quiet) {
        return {
          update: () => {},
          success: () => {},
          fail: () => {},
          stop: () => {}
        };
      }
      const frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
      let frameIndex = 0;
      let currentMsg = msg;
      const interval = setInterval(() => {
        process.stdout.write(`\r${cyan(frames[frameIndex])} ${currentMsg}`);
        frameIndex = (frameIndex + 1) % frames.length;
      }, 80);
      return {
        update(newMsg) {
          currentMsg = newMsg;
        },
        success(successMsg) {
          clearInterval(interval);
          process.stdout.write(`\r${success(symbols.success)} ${successMsg || currentMsg}
`);
        },
        fail(failMsg) {
          clearInterval(interval);
          process.stdout.write(`\r${error(symbols.error)} ${failMsg || currentMsg}
`);
        },
        stop() {
          clearInterval(interval);
          process.stdout.write("\r" + " ".repeat(currentMsg.length + 3) + "\r");
        }
      };
    }
  };
}

// src/utils/prompt.ts
function createPromptHelper() {
  return {
    async text(message, options) {
      if (!isTTY()) {
        throw new Error("Cannot prompt in non-interactive mode");
      }
      const prompt = options?.default ? `${message} ${dim(`(${options.default})`)}: ` : `${message}: `;
      process.stdout.write(prompt);
      const response = await readLine();
      const value = response.trim() || options?.default || "";
      if (options?.validate) {
        const result = options.validate(value);
        if (result !== true) {
          console.log(error(typeof result === "string" ? result : "Invalid input"));
          return this.text(message, options);
        }
      }
      return value;
    },
    async confirm(message, defaultValue = false) {
      if (!isTTY()) {
        return defaultValue;
      }
      const hint = defaultValue ? "Y/n" : "y/N";
      process.stdout.write(`${message} ${dim(`(${hint})`)}: `);
      const response = await readLine();
      const trimmed = response.trim().toLowerCase();
      if (!trimmed)
        return defaultValue;
      return trimmed === "y" || trimmed === "yes";
    },
    async select(message, options) {
      if (!isTTY()) {
        return options[0].value;
      }
      console.log(`
${message}
`);
      for (let i = 0;i < options.length; i++) {
        const opt = options[i];
        console.log(`  ${cyan(`${i + 1})`)} ${opt.label}${opt.description ? dim(` - ${opt.description}`) : ""}`);
      }
      process.stdout.write(`
${dim("Enter number")}: `);
      const response = await readLine();
      const index = parseInt(response.trim(), 10) - 1;
      if (isNaN(index) || index < 0 || index >= options.length) {
        console.log(error("Invalid selection"));
        return this.select(message, options);
      }
      return options[index].value;
    },
    async multiselect(message, options) {
      if (!isTTY()) {
        return [];
      }
      console.log(`
${message} ${dim("(comma-separated numbers)")}
`);
      for (let i = 0;i < options.length; i++) {
        const opt = options[i];
        console.log(`  ${cyan(`${i + 1})`)} ${opt.label}${opt.description ? dim(` - ${opt.description}`) : ""}`);
      }
      process.stdout.write(`
${dim("Enter numbers")}: `);
      const response = await readLine();
      const indices = response.split(",").map((s) => parseInt(s.trim(), 10) - 1).filter((i) => !isNaN(i) && i >= 0 && i < options.length);
      return indices.map((i) => options[i].value);
    },
    async password(message) {
      if (!isTTY()) {
        throw new Error("Cannot prompt for password in non-interactive mode");
      }
      process.stdout.write(`${message}: `);
      const response = await readLine();
      return response;
    }
  };
}
async function readLine() {
  return new Promise((resolve) => {
    const stdin = process.stdin;
    const isRaw = stdin.isRaw;
    stdin.setRawMode?.(false);
    stdin.resume();
    let data = "";
    const onData = (chunk) => {
      const str = chunk.toString();
      if (str.includes(`
`) || str.includes("\r")) {
        stdin.removeListener("data", onData);
        stdin.pause();
        stdin.setRawMode?.(isRaw ?? false);
        resolve(data + str.replace(/[\r\n]/g, ""));
      } else {
        data += str;
      }
    };
    stdin.on("data", onData);
  });
}

// src/core/completions.ts
async function generateZshCompletions() {
  const services = await registry.list();
  const aliases = config.getAliases();
  const flows = config.getFlows();
  let completions = `#compdef uni

# uni CLI completions for Zsh
# Add to ~/.zshrc: eval "$(uni completions zsh)"

_uni() {
  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -C \\
    '1: :->service' \\
    '2: :->command' \\
    '3: :->subcommand' \\
    '*::arg:->args'

  case $state in
    service)
      local services=(
`;
  for (const svc of services) {
    completions += `        '${svc.name}:${svc.description.replace(/'/g, "\\'")}'
`;
  }
  for (const [name, cmd] of Object.entries(aliases)) {
    completions += `        '${name}:alias \u2192 ${cmd.replace(/'/g, "\\'")}'
`;
  }
  for (const [name, cmds] of Object.entries(flows)) {
    const preview = cmds.slice(0, 2).join(" \u2192 ");
    completions += `        '${name}:flow \u2192 ${preview.replace(/'/g, "\\'")}'
`;
  }
  completions += `        'list:List available services'
        'ask:Natural language commands'
        'run:Run multiple commands'
        'flow:Manage saved command macros'
        'install:Install a service package'
        'uninstall:Uninstall a service package'
        'auth:Manage authentication'
        'config:Manage configuration'
        'alias:Manage command aliases'
        'history:View command history'
        'completions:Generate shell completions'
      )
      _describe 'service' services
      ;;

    command)
      case $line[1] in
`;
  for (const svc of services) {
    const service = await registry.load(svc.name);
    completions += `        ${svc.name})
          local commands=(
`;
    for (const cmd of service.commands) {
      const desc = cmd.description.replace(/'/g, "\\'");
      completions += `            '${cmd.name}:${desc}'
`;
    }
    completions += `          )
          _describe 'command' commands
          ;;
`;
  }
  completions += `      esac
      ;;

    subcommand)
      case $line[1] in
`;
  for (const svc of services) {
    const service = await registry.load(svc.name);
    for (const cmd of service.commands) {
      if (cmd.subcommands) {
        completions += `        ${svc.name})
          case $line[2] in
            ${cmd.name})
              local subcommands=(
`;
        for (const sub of cmd.subcommands) {
          const desc = sub.description.replace(/'/g, "\\'");
          completions += `                '${sub.name}:${desc}'
`;
        }
        completions += `              )
              _describe 'subcommand' subcommands
              ;;
          esac
          ;;
`;
      }
    }
  }
  completions += `      esac
      ;;
  esac
}

_uni "$@"
`;
  return completions;
}
async function generateBashCompletions() {
  const services = await registry.list();
  const aliases = config.getAliases();
  const flows = config.getFlows();
  const aliasNames = Object.keys(aliases).join(" ");
  const flowNames = Object.keys(flows).join(" ");
  const serviceNames = services.map((s) => s.name).join(" ");
  let completions = `# uni CLI completions for Bash
# Add to ~/.bashrc: eval "$(uni completions bash)"

_uni_completions() {
  local cur prev services commands
  COMPREPLY=()
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"

  services="${serviceNames} ${aliasNames} ${flowNames} list ask run flow install uninstall auth config alias history completions"

  if [[ \${COMP_CWORD} -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "\${services}" -- "\${cur}") )
    return 0
  fi

  case "\${COMP_WORDS[1]}" in
`;
  for (const svc of services) {
    const service = await registry.load(svc.name);
    const cmdNames = service.commands.map((c) => c.name).join(" ");
    completions += `    ${svc.name})
      commands="${cmdNames}"
      ;;
`;
  }
  completions += `  esac

  if [[ \${COMP_CWORD} -eq 2 ]]; then
    COMPREPLY=( $(compgen -W "\${commands}" -- "\${cur}") )
    return 0
  fi
}

complete -F _uni_completions uni
`;
  return completions;
}
async function generateFishCompletions() {
  const services = await registry.list();
  const aliases = config.getAliases();
  const flows = config.getFlows();
  let completions = `# uni CLI completions for Fish
# Add to ~/.config/fish/completions/uni.fish

# Disable file completion
complete -c uni -f

# Services
`;
  for (const svc of services) {
    completions += `complete -c uni -n "__fish_use_subcommand" -a "${svc.name}" -d "${svc.description}"
`;
  }
  for (const [name, cmd] of Object.entries(aliases)) {
    completions += `complete -c uni -n "__fish_use_subcommand" -a "${name}" -d "alias \u2192 ${cmd}"
`;
  }
  for (const [name, cmds] of Object.entries(flows)) {
    const preview = cmds.slice(0, 2).join(" \u2192 ");
    completions += `complete -c uni -n "__fish_use_subcommand" -a "${name}" -d "flow \u2192 ${preview}"
`;
  }
  completions += `complete -c uni -n "__fish_use_subcommand" -a "list" -d "List available services"
complete -c uni -n "__fish_use_subcommand" -a "ask" -d "Natural language commands"
complete -c uni -n "__fish_use_subcommand" -a "run" -d "Run multiple commands"
complete -c uni -n "__fish_use_subcommand" -a "flow" -d "Manage saved command macros"
complete -c uni -n "__fish_use_subcommand" -a "install" -d "Install a service package"
complete -c uni -n "__fish_use_subcommand" -a "uninstall" -d "Uninstall a service package"
complete -c uni -n "__fish_use_subcommand" -a "auth" -d "Manage authentication"
complete -c uni -n "__fish_use_subcommand" -a "config" -d "Manage configuration"
complete -c uni -n "__fish_use_subcommand" -a "alias" -d "Manage command aliases"
complete -c uni -n "__fish_use_subcommand" -a "history" -d "View command history"
complete -c uni -n "__fish_use_subcommand" -a "completions" -d "Generate shell completions"

# Commands per service
`;
  for (const svc of services) {
    const service = await registry.load(svc.name);
    for (const cmd of service.commands) {
      completions += `complete -c uni -n "__fish_seen_subcommand_from ${svc.name}" -a "${cmd.name}" -d "${cmd.description}"
`;
      if (cmd.subcommands) {
        for (const sub of cmd.subcommands) {
          completions += `complete -c uni -n "__fish_seen_subcommand_from ${cmd.name}" -a "${sub.name}" -d "${sub.description}"
`;
        }
      }
    }
  }
  return completions;
}

// src/core/cli.ts
import * as readline from "readline";
var VERSION = "0.1.0";

class UniCLI {
  async run(argv) {
    const parsed2 = parseArgs(argv);
    const output = createOutputFormatter(parsed2.globalFlags);
    try {
      await config.load(parsed2.globalFlags.config);
      if (parsed2.globalFlags.help && !parsed2.service) {
        this.showGlobalHelp(output);
        return;
      }
      if (parsed2.globalFlags.version) {
        this.showVersion(output, parsed2.globalFlags);
        return;
      }
      if (!parsed2.service) {
        this.showGlobalHelp(output);
        return;
      }
      if (parsed2.service === "list") {
        await this.listServices(output, parsed2.globalFlags);
        return;
      }
      if (parsed2.service === "auth") {
        await this.handleAuth(parsed2, output);
        return;
      }
      if (parsed2.service === "config") {
        await this.handleConfig(parsed2, output);
        return;
      }
      if (parsed2.service === "completions") {
        await this.handleCompletions(parsed2, output);
        return;
      }
      if (parsed2.service === "alias") {
        await this.handleAlias(parsed2, output);
        return;
      }
      if (parsed2.service === "history") {
        await this.handleHistory(parsed2, output);
        return;
      }
      if (parsed2.service === "ask") {
        await this.handleAsk(parsed2, output);
        return;
      }
      if (parsed2.service === "run") {
        await this.handleRun(parsed2, output);
        return;
      }
      if (parsed2.service === "flow") {
        await this.handleFlow(parsed2, output);
        return;
      }
      if (parsed2.service === "install") {
        await this.handleInstall(parsed2, output);
        return;
      }
      if (parsed2.service === "uninstall") {
        await this.handleUninstall(parsed2, output);
        return;
      }
      const aliasCommand = config.getAlias(parsed2.service);
      if (aliasCommand) {
        const expandedArgs = aliasCommand.split(/\s+/).concat(parsed2.command ? [parsed2.command] : [], parsed2.subcommand ? [parsed2.subcommand] : [], parsed2.args);
        const expandedParsed = parseArgs(expandedArgs);
        expandedParsed.globalFlags = { ...expandedParsed.globalFlags, ...parsed2.globalFlags };
        return this.runExpanded(expandedParsed, output);
      }
      const flowCommands = flow.getFlow(parsed2.service);
      if (flowCommands) {
        const flowArgs = [
          parsed2.command,
          parsed2.subcommand,
          ...parsed2.args
        ].filter(Boolean);
        const substituted = substituteArgs(flowCommands, flowArgs);
        const isDryRun = parsed2.flags["dry-run"] || parsed2.flags.n;
        const isParallel = parsed2.flags.parallel || parsed2.flags.p;
        await runCommands(substituted, {
          dryRun: !!isDryRun,
          parallel: !!isParallel,
          json: parsed2.globalFlags.json
        });
        return;
      }
      const exists = await registry.has(parsed2.service);
      if (!exists) {
        throw new UniError(`Unknown service or command: '${parsed2.service}'`, "UNKNOWN_SERVICE", `Run 'uni list' to see available services, or 'uni --help' for usage`);
      }
      const service = await registry.load(parsed2.service);
      if (parsed2.globalFlags.help || !parsed2.command) {
        this.showServiceHelp(service, output);
        return;
      }
      const baseCommand = service.commands.find((c) => c.name === parsed2.command || c.aliases?.includes(parsed2.command));
      if (!baseCommand) {
        const availableCommands = service.commands.map((c) => c.name);
        throw new CommandNotFoundError(parsed2.service, parsed2.command, availableCommands);
      }
      let command = baseCommand;
      let commandArgs = parsed2.args;
      if (parsed2.subcommand) {
        if (baseCommand.subcommands) {
          const subcommand = baseCommand.subcommands.find((c) => c.name === parsed2.subcommand || c.aliases?.includes(parsed2.subcommand));
          if (subcommand) {
            command = subcommand;
          } else {
            commandArgs = [parsed2.subcommand, ...parsed2.args];
          }
        } else {
          commandArgs = [parsed2.subcommand, ...parsed2.args];
        }
      }
      const { args, flags } = parseCommandArgs(commandArgs, parsed2.flags, command.args, command.options);
      const ctx = {
        args,
        flags,
        rawArgs: parsed2.raw,
        config: config.getService(parsed2.service),
        auth: null,
        output,
        prompt: createPromptHelper(),
        globalFlags: parsed2.globalFlags
      };
      await command.handler(ctx);
      const cmdString = this.buildCommandString(parsed2);
      await history.addCommand(cmdString, 0);
    } catch (error2) {
      const cmdString = this.buildCommandString(parsed2);
      await history.addCommand(cmdString, 1);
      if (error2 instanceof UniError) {
        output.error(error2.message);
        if (error2.suggestion) {
          output.info(error2.suggestion);
        }
        process.exit(1);
      }
      output.error(error2 instanceof Error ? error2.message : String(error2));
      if (parsed2.globalFlags.verbose) {
        console.error(error2);
      }
      process.exit(1);
    }
  }
  buildCommandString(parsed2) {
    const parts = [parsed2.service];
    if (parsed2.command)
      parts.push(parsed2.command);
    if (parsed2.subcommand)
      parts.push(parsed2.subcommand);
    parts.push(...parsed2.args);
    for (const [key, value] of Object.entries(parsed2.flags)) {
      if (typeof value === "boolean" && value) {
        parts.push(`--${key}`);
      } else if (typeof value !== "boolean") {
        parts.push(`--${key}`, String(value));
      }
    }
    return parts.filter(Boolean).join(" ");
  }
  async runExpanded(parsed2, output) {
    const exists = await registry.has(parsed2.service);
    if (!exists) {
      throw new UniError(`Unknown service: '${parsed2.service}'`, "UNKNOWN_SERVICE", `Run 'uni list' to see available services`);
    }
    const service = await registry.load(parsed2.service);
    if (parsed2.globalFlags.help || !parsed2.command) {
      this.showServiceHelp(service, output);
      return;
    }
    const baseCommand = service.commands.find((c) => c.name === parsed2.command || c.aliases?.includes(parsed2.command));
    if (!baseCommand) {
      const availableCommands = service.commands.map((c) => c.name);
      throw new CommandNotFoundError(parsed2.service, parsed2.command, availableCommands);
    }
    let command = baseCommand;
    let commandArgs = parsed2.args;
    if (parsed2.subcommand) {
      if (baseCommand.subcommands) {
        const subcommand = baseCommand.subcommands.find((c) => c.name === parsed2.subcommand || c.aliases?.includes(parsed2.subcommand));
        if (subcommand) {
          command = subcommand;
        } else {
          commandArgs = [parsed2.subcommand, ...parsed2.args];
        }
      } else {
        commandArgs = [parsed2.subcommand, ...parsed2.args];
      }
    }
    const { args, flags } = parseCommandArgs(commandArgs, parsed2.flags, command.args, command.options);
    const ctx = {
      args,
      flags,
      rawArgs: parsed2.raw,
      config: config.getService(parsed2.service),
      auth: null,
      output,
      prompt: createPromptHelper(),
      globalFlags: parsed2.globalFlags
    };
    try {
      await command.handler(ctx);
      const cmdString = this.buildCommandString(parsed2);
      await history.addCommand(cmdString, 0);
    } catch (error2) {
      const cmdString = this.buildCommandString(parsed2);
      await history.addCommand(cmdString, 1);
      throw error2;
    }
  }
  findCommand(service, commandName, subcommandName) {
    const command = service.commands.find((c) => c.name === commandName || c.aliases?.includes(commandName));
    if (!command)
      return null;
    if (subcommandName && command.subcommands) {
      const subcommand = command.subcommands.find((c) => c.name === subcommandName || c.aliases?.includes(subcommandName));
      return subcommand || null;
    }
    return command;
  }
  showGlobalHelp(output) {
    console.log(`
${bold("uni")} - Universal CLI for everything

${bold("USAGE")}
  uni <service> <command> [options] [args]
  uni <command> [options]

${bold("GLOBAL OPTIONS")}
  -h, --help      Show help
  -v, --version   Show version
  --json          Output as JSON
  --verbose       Verbose output
  -q, --quiet     Suppress output
  -c, --config    Custom config path

${bold("COMMANDS")}
  list            List available services
  ask             Natural language commands
  run             Run multiple commands at once
  flow            Manage saved command macros
  install         Install a service package
  uninstall       Uninstall a service package
  auth            Manage authentication
  config          Manage configuration
  alias           Manage command aliases
  history         View command history
  completions     Generate shell completions

${bold("EXAMPLES")}
  uni exa search "React hooks"
  uni gh pr list
  uni gcal add "Meeting" --time 10am
  uni run "gh pr list" "gcal list"
  uni flow add standup "gcal list" "gh pr list"

${muted(`Run 'uni <service> --help' for service-specific help`)}
`);
  }
  showVersion(output, flags) {
    if (flags.json) {
      output.json({ version: VERSION });
    } else {
      console.log(`uni v${VERSION}`);
    }
  }
  async listServices(output, flags) {
    const services = await registry.list();
    if (services.length === 0) {
      if (flags.json) {
        output.json({ services: [] });
      } else {
        output.info("No services installed");
        console.log(`
${muted("Install services with 'uni install <service>'")}`);
      }
      return;
    }
    if (flags.json) {
      output.json({ services });
    } else {
      console.log(`
${bold("Available Services")}
`);
      for (const service of services) {
        console.log(`  ${cyan(service.name.padEnd(12))} ${muted(service.description)} ${dim(`[${service.source}]`)}`);
      }
      console.log(`
${muted("Run 'uni <service> --help' for more info")}
`);
    }
  }
  showServiceHelp(service, output) {
    console.log(`
${bold(`uni ${service.name}`)} - ${service.description}

${bold("COMMANDS")}`);
    for (const cmd of service.commands) {
      const aliases = cmd.aliases ? ` ${dim(`(${cmd.aliases.join(", ")})`)}` : "";
      console.log(`  ${cyan(cmd.name.padEnd(16))}${aliases} ${cmd.description}`);
      if (cmd.subcommands) {
        for (const sub of cmd.subcommands) {
          console.log(`    ${cyan(sub.name.padEnd(14))} ${sub.description}`);
        }
      }
    }
    const commandsWithExamples = service.commands.filter((c) => c.examples?.length);
    if (commandsWithExamples.length > 0) {
      console.log(`
${bold("EXAMPLES")}`);
      for (const cmd of commandsWithExamples) {
        for (const example of cmd.examples || []) {
          console.log(`  ${dim("$")} ${example}`);
        }
      }
    }
    console.log("");
  }
  async handleAuth(parsed2, output) {
    output.info("Auth commands coming soon");
    console.log(`
  uni auth login <service>   Login to a service
  uni auth logout <service>  Logout from a service
  uni auth status            Show auth status
`);
  }
  async handleConfig(parsed2, output) {
    const subcommand = parsed2.command || "show";
    const args = parsed2.subcommand ? [parsed2.subcommand, ...parsed2.args] : parsed2.args;
    switch (subcommand) {
      case "show": {
        const fullConfig = config.getFullConfig();
        if (parsed2.globalFlags.json) {
          output.json(fullConfig);
        } else {
          console.log(`
${bold("Configuration")}
`);
          console.log(`  ${cyan("Path:")} ${config.getGlobalConfigPath()}`);
          console.log(`
${bold("[global]")}`);
          const global = config.getGlobal();
          for (const [key, value] of Object.entries(global)) {
            console.log(`  ${cyan(key)} = ${yellow(String(value))}`);
          }
          const services = fullConfig?.services ?? {};
          for (const [name, svc] of Object.entries(services)) {
            if (Object.keys(svc).length > 0) {
              console.log(`
${bold(`[services.${name}]`)}`);
              for (const [key, value] of Object.entries(svc)) {
                console.log(`  ${cyan(key)} = ${yellow(String(value))}`);
              }
            }
          }
          const aliases = config.getAliases();
          if (Object.keys(aliases).length > 0) {
            console.log(`
${bold("[aliases]")}`);
            for (const [name, cmd] of Object.entries(aliases)) {
              console.log(`  ${cyan(name)} = ${yellow(`"${cmd}"`)}`);
            }
          }
          console.log("");
        }
        break;
      }
      case "get": {
        const key = args[0];
        if (!key) {
          output.error("Usage: uni config get <key>");
          console.log(`
${muted("Example: uni config get global.color")}`);
          process.exit(1);
        }
        const value = config.get(key);
        if (parsed2.globalFlags.json) {
          output.json({ key, value });
        } else if (value !== undefined) {
          console.log(String(value));
        } else {
          output.error(`Key not found: ${key}`);
          process.exit(1);
        }
        break;
      }
      case "set": {
        const key = args[0];
        const value = args.slice(1).join(" ");
        if (!key || !value) {
          output.error("Usage: uni config set <key> <value>");
          console.log(`
${muted("Example: uni config set global.color false")}`);
          process.exit(1);
        }
        await config.set(key, this.parseConfigValue(value));
        output.success(`Set ${key} = ${value}`);
        break;
      }
      case "edit": {
        const editor = config.getGlobal().editor || process.env.EDITOR || "vim";
        const configPath = config.getGlobalConfigPath();
        await config.ensureConfigDir();
        const fs4 = await import("fs");
        if (!fs4.existsSync(configPath)) {
          fs4.writeFileSync(configPath, `# uni CLI configuration

[global]
color = true
`);
        }
        const { spawn } = await import("child_process");
        const child = spawn(editor, [configPath], { stdio: "inherit" });
        await new Promise((resolve, reject) => {
          child.on("close", (code) => {
            if (code === 0)
              resolve();
            else
              reject(new Error(`Editor exited with code ${code}`));
          });
        });
        break;
      }
      case "path": {
        const configPath = config.getGlobalConfigPath();
        if (parsed2.globalFlags.json) {
          output.json({ path: configPath });
        } else {
          console.log(configPath);
        }
        break;
      }
      default: {
        output.error(`Unknown config command: ${subcommand}`);
        console.log(`
${bold("Usage:")}
  uni config show             Show all configuration
  uni config get <key>        Get a specific value
  uni config set <key> <val>  Set a value
  uni config edit             Open config in editor
  uni config path             Show config file path
`);
        process.exit(1);
      }
    }
  }
  async handleAlias(parsed2, output) {
    const subcommand = parsed2.command || "list";
    const args = parsed2.subcommand ? [parsed2.subcommand, ...parsed2.args] : parsed2.args;
    switch (subcommand) {
      case "list": {
        const aliases = config.getAliases();
        const entries = Object.entries(aliases);
        if (parsed2.globalFlags.json) {
          output.json({ aliases });
        } else if (entries.length === 0) {
          console.log(`
${muted("No aliases defined")}`);
          console.log(`${muted("Use 'uni alias add <name> <command>' to create one")}
`);
        } else {
          console.log(`
${bold("Aliases")}
`);
          for (const [name, cmd] of entries) {
            console.log(`  ${cyan(name.padEnd(12))} \u2192 ${cmd}`);
          }
          console.log("");
        }
        break;
      }
      case "add": {
        const name = args[0];
        const command = args.slice(1).join(" ");
        if (!name || !command) {
          output.error("Usage: uni alias add <name> <command>");
          console.log(`
${muted('Example: uni alias add prs "gh pr list --state open"')}`);
          process.exit(1);
        }
        const services = await registry.list();
        const builtins = ["list", "auth", "config", "completions", "alias", "history"];
        if (services.some((s) => s.name === name) || builtins.includes(name)) {
          output.error(`Cannot create alias '${name}': conflicts with service or builtin command`);
          process.exit(1);
        }
        await config.setAlias(name, command);
        output.success(`Created alias: ${name} \u2192 ${command}`);
        break;
      }
      case "remove":
      case "rm":
      case "delete": {
        const name = args[0];
        if (!name) {
          output.error("Usage: uni alias remove <name>");
          process.exit(1);
        }
        const removed = await config.removeAlias(name);
        if (removed) {
          output.success(`Removed alias: ${name}`);
        } else {
          output.error(`Alias not found: ${name}`);
          process.exit(1);
        }
        break;
      }
      default: {
        output.error(`Unknown alias command: ${subcommand}`);
        console.log(`
${bold("Usage:")}
  uni alias list                 List all aliases
  uni alias add <name> <cmd>     Create an alias
  uni alias remove <name>        Remove an alias
`);
        process.exit(1);
      }
    }
  }
  async handleHistory(parsed2, output) {
    const subcommand = parsed2.command || "list";
    const args = parsed2.subcommand ? [parsed2.subcommand, ...parsed2.args] : parsed2.args;
    switch (subcommand) {
      case "list":
      default: {
        const isListCommand = subcommand === "list";
        const limit = parsed2.flags.limit ? Number(parsed2.flags.limit) : parsed2.flags.l ? Number(parsed2.flags.l) : 20;
        const search = parsed2.flags.search;
        const entries = await history.getHistory({ limit, search });
        if (parsed2.globalFlags.json) {
          output.json({ history: entries });
        } else if (entries.length === 0) {
          console.log(`
${muted("No commands in history")}
`);
        } else {
          console.log(`
${bold("Command History")}
`);
          for (const entry of entries) {
            const status = entry.exit === 0 ? green("\u2713") : red("\u2717");
            const time = new Date(entry.time).toLocaleString();
            console.log(`  ${dim(String(entry.id).padStart(4))}  ${status}  ${entry.cmd}  ${dim(time)}`);
          }
          console.log(`
${muted("Run 'uni history run <id>' to re-execute a command")}
`);
        }
        break;
      }
      case "run": {
        const idArg = args[0];
        if (!idArg) {
          output.error("Usage: uni history run <id>");
          process.exit(1);
        }
        const id = Number(idArg);
        if (isNaN(id)) {
          output.error("Invalid history ID");
          process.exit(1);
        }
        const entry = await history.getCommand(id);
        if (!entry) {
          output.error(`History entry not found: ${id}`);
          process.exit(1);
        }
        console.log(`${dim("\u2192")} ${entry.cmd}
`);
        const expandedParsed = parseArgs(entry.cmd.split(/\s+/));
        expandedParsed.globalFlags = { ...expandedParsed.globalFlags, ...parsed2.globalFlags };
        await this.runFromHistory(expandedParsed, output);
        break;
      }
      case "clear": {
        await history.clearHistory();
        output.success("History cleared");
        break;
      }
      case "path": {
        console.log(history.getPath());
        break;
      }
    }
  }
  async runFromHistory(parsed2, output) {
    if (!parsed2.service) {
      output.error("Invalid command");
      return;
    }
    const aliasCommand = config.getAlias(parsed2.service);
    if (aliasCommand) {
      const expandedArgs = aliasCommand.split(/\s+/).concat(parsed2.command ? [parsed2.command] : [], parsed2.subcommand ? [parsed2.subcommand] : [], parsed2.args);
      const expandedParsed = parseArgs(expandedArgs);
      expandedParsed.globalFlags = { ...expandedParsed.globalFlags, ...parsed2.globalFlags };
      return this.runExpanded(expandedParsed, output);
    }
    return this.runExpanded(parsed2, output);
  }
  parseConfigValue(value) {
    if (value === "true")
      return true;
    if (value === "false")
      return false;
    const num = Number(value);
    if (!isNaN(num))
      return num;
    if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
      return value.slice(1, -1);
    }
    return value;
  }
  async handleAsk(parsed2, output) {
    const isInteractive = parsed2.flags.interactive || parsed2.flags.i;
    const isDryRun = parsed2.flags["dry-run"] || parsed2.flags.n;
    const noConfirm = parsed2.flags["no-confirm"];
    const providerOverride = parsed2.flags.provider;
    const query = parsed2.command ? [parsed2.command, parsed2.subcommand, ...parsed2.args].filter(Boolean).join(" ") : "";
    if (isInteractive) {
      await this.runAskInteractive(output, providerOverride, isDryRun, noConfirm);
      return;
    }
    if (!query) {
      console.log(`
${bold("uni ask")} - Natural language commands

${bold("Usage:")}
  uni ask "your query here"
  uni ask -i                    # Interactive mode

${bold("Options:")}
  -n, --dry-run      Show command without executing
  --no-confirm       Execute without confirmation
  --provider <name>  Override LLM provider (anthropic|openai|ollama|groq)
  -i, --interactive  Start interactive mode

${bold("Examples:")}
  uni ask "show my calendar for tomorrow"
  uni ask "search for React tutorials"
  uni ask "list my open pull requests"

${bold("Configuration:")}
  Set provider in ~/.uni/config.toml:

  [ask]
  provider = "anthropic"
  model = "claude-3-haiku-20240307"
  confirm = true
`);
      return;
    }
    await this.processAskQuery(query, output, providerOverride, isDryRun, noConfirm);
  }
  async processAskQuery(query, output, providerOverride, isDryRun, noConfirm) {
    const askConfig = config.getAsk();
    const shouldConfirm = !noConfirm && askConfig.confirm !== false;
    try {
      const llmConfig = {
        provider: providerOverride || askConfig.provider,
        model: askConfig.model,
        baseUrl: askConfig.ollamaUrl
      };
      const llm = createLLMClient(llmConfig);
      const systemPrompt = await this.generateAskSystemPrompt();
      process.stdout.write(dim("Thinking..."));
      const response = await llm.complete(query, systemPrompt);
      process.stdout.write("\r" + " ".repeat(20) + "\r");
      const command = this.parseAskResponse(response);
      if (!command) {
        output.error("Could not generate a command for that request");
        if (response) {
          console.log(dim(response));
        }
        return;
      }
      console.log(`${dim("\u2192")} ${cyan(command)}`);
      if (isDryRun) {
        return;
      }
      if (shouldConfirm) {
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        });
        const answer = await new Promise((resolve) => {
          rl.question(`${dim("Run this command?")} ${muted("[Y/n]")} `, resolve);
        });
        rl.close();
        if (answer.toLowerCase() === "n" || answer.toLowerCase() === "no") {
          console.log(muted("Cancelled"));
          return;
        }
      }
      console.log("");
      const cmdParts = this.parseCommandString(command);
      const cmdParsed = parseArgs(cmdParts);
      cmdParsed.globalFlags = { ...cmdParsed.globalFlags, ...parsed.globalFlags };
      await this.runFromHistory(cmdParsed, output);
    } catch (error2) {
      output.error(error2 instanceof Error ? error2.message : String(error2));
    }
  }
  async runAskInteractive(output, providerOverride, isDryRun, noConfirm) {
    console.log(`
${bold("uni ask")} - Interactive Mode
${dim('Type your requests in natural language. Type "exit" or "quit" to leave.')}
`);
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    const prompt = () => {
      rl.question(`${green(">")} `, async (query) => {
        const trimmed = query.trim();
        if (!trimmed) {
          prompt();
          return;
        }
        if (trimmed === "exit" || trimmed === "quit" || trimmed === "q") {
          rl.close();
          return;
        }
        await this.processAskQuery(trimmed, output, providerOverride, isDryRun, noConfirm);
        console.log("");
        prompt();
      });
    };
    prompt();
    await new Promise((resolve) => {
      rl.on("close", resolve);
    });
  }
  async generateAskSystemPrompt() {
    const services = await registry.list();
    const aliases = config.getAliases();
    let commandList = "";
    for (const svc of services) {
      try {
        const service = await registry.load(svc.name);
        commandList += `
## ${svc.name} - ${svc.description}
`;
        for (const cmd of service.commands) {
          commandList += `  uni ${svc.name} ${cmd.name}`;
          if (cmd.args) {
            for (const arg of cmd.args) {
              commandList += arg.required ? ` <${arg.name}>` : ` [${arg.name}]`;
            }
          }
          if (cmd.options) {
            for (const opt of cmd.options.slice(0, 3)) {
              commandList += ` --${opt.name}`;
            }
          }
          commandList += `
    ${cmd.description}
`;
          if (cmd.subcommands) {
            for (const sub of cmd.subcommands) {
              commandList += `  uni ${svc.name} ${cmd.name} ${sub.name} - ${sub.description}
`;
            }
          }
        }
      } catch {}
    }
    if (Object.keys(aliases).length > 0) {
      commandList += `
## Aliases
`;
      for (const [name, cmd] of Object.entries(aliases)) {
        commandList += `  uni ${name} \u2192 ${cmd}
`;
      }
    }
    return `You are a CLI command translator for the uni CLI tool. Given a natural language request, return the appropriate uni CLI command.

Available commands:
${commandList}

Rules:
1. Return ONLY the command, nothing else. No explanations, no markdown, no quotes.
2. Use exact command and flag names from the list above.
3. If the request is ambiguous, make a reasonable assumption.
4. If the request cannot be fulfilled with available commands, respond with: CANNOT: <brief reason>
5. Always start commands with "uni" (not the service name directly).

Examples:
User: show my calendar
Command: uni gcal list

User: search for react tutorials
Command: uni exa search "react tutorials"

User: show open pull requests
Command: uni gh pr list --state open

User: send hello to general channel on slack
Command: uni slack send general "hello"`;
  }
  parseAskResponse(response) {
    const trimmed = response.trim();
    if (trimmed.startsWith("CANNOT:")) {
      return null;
    }
    let command = trimmed;
    if (command.toLowerCase().startsWith("command:")) {
      command = command.slice(8).trim();
    }
    if (command.startsWith("```")) {
      command = command.replace(/```[a-z]*\n?/g, "").replace(/```/g, "").trim();
    }
    if (command.startsWith('"') && command.endsWith('"') || command.startsWith("'") && command.endsWith("'")) {
      command = command.slice(1, -1);
    }
    if (!command.startsWith("uni ")) {
      if (command.match(/^[a-z]+ [a-z]/)) {
        command = "uni " + command;
      } else {
        return null;
      }
    }
    return command.startsWith("uni ") ? command.slice(4) : command;
  }
  parseCommandString(command) {
    const parts = [];
    let current = "";
    let inQuotes = false;
    let quoteChar = "";
    for (const char of command) {
      if ((char === '"' || char === "'") && !inQuotes) {
        inQuotes = true;
        quoteChar = char;
      } else if (char === quoteChar && inQuotes) {
        inQuotes = false;
        quoteChar = "";
      } else if (char === " " && !inQuotes) {
        if (current) {
          parts.push(current);
          current = "";
        }
      } else {
        current += char;
      }
    }
    if (current) {
      parts.push(current);
    }
    return parts;
  }
  async handleCompletions(parsed2, output) {
    const shell = parsed2.command || "zsh";
    switch (shell) {
      case "zsh":
        console.log(await generateZshCompletions());
        break;
      case "bash":
        console.log(await generateBashCompletions());
        break;
      case "fish":
        console.log(await generateFishCompletions());
        break;
      default:
        output.error(`Unknown shell: ${shell}`);
        console.log(`
${bold("Usage:")}`);
        console.log(`  uni completions zsh   # For Zsh`);
        console.log(`  uni completions bash  # For Bash`);
        console.log(`  uni completions fish  # For Fish`);
        console.log(`
${bold("Setup:")}`);
        console.log(`  ${cyan("Zsh:")}  eval "$(uni completions zsh)"`);
        console.log(`  ${cyan("Bash:")} eval "$(uni completions bash)"`);
        console.log(`  ${cyan("Fish:")} uni completions fish > ~/.config/fish/completions/uni.fish`);
        console.log("");
    }
  }
  async handleRun(parsed2, output) {
    const commands = [
      parsed2.command,
      parsed2.subcommand,
      ...parsed2.args
    ].filter(Boolean);
    if (commands.length === 0) {
      console.log(`
${bold("uni run")} - Run multiple commands

${bold("Usage:")}
  uni run "cmd1" "cmd2" "cmd3"

${bold("Options:")}
  -p, --parallel   Run commands in parallel
  -n, --dry-run    Show commands without executing
  --json           Output results as JSON

${bold("Examples:")}
  uni run "gh pr list" "gcal list"
  uni run -p "gh pr list" "gcal list" "exa search 'news'"
  uni run --dry-run "gh pr create" "slack send general 'PR ready'"
`);
      return;
    }
    const isDryRun = parsed2.flags["dry-run"] || parsed2.flags.n;
    const isParallel = parsed2.flags.parallel || parsed2.flags.p;
    const results = await runCommands(commands, {
      dryRun: !!isDryRun,
      parallel: !!isParallel,
      json: parsed2.globalFlags.json
    });
    if (parsed2.globalFlags.json) {
      output.json({ results });
    }
  }
  async handleFlow(parsed2, output) {
    const subcommand = parsed2.command || "list";
    const args = parsed2.subcommand ? [parsed2.subcommand, ...parsed2.args] : parsed2.args;
    switch (subcommand) {
      case "list": {
        const flows = flow.getFlows();
        const entries = Object.entries(flows);
        if (parsed2.globalFlags.json) {
          output.json({ flows });
        } else if (entries.length === 0) {
          console.log(`
${muted("No flows defined")}`);
          console.log(`${muted("Use 'uni flow add <name> <commands...>' to create one")}
`);
        } else {
          console.log(`
${bold("Flows")}
`);
          for (const [name, commands] of entries) {
            const preview = commands.join(` ${dim("\u2192")} `);
            console.log(`  ${cyan(name.padEnd(12))} ${preview}`);
          }
          console.log(`
${muted("Run 'uni <flowname>' or 'uni flow run <name>' to execute")}
`);
        }
        break;
      }
      case "add": {
        const name = args[0];
        const commands = args.slice(1);
        if (!name || commands.length === 0) {
          output.error("Usage: uni flow add <name> <commands...>");
          console.log(`
${muted('Example: uni flow add standup "gcal list" "gh pr list --mine"')}`);
          process.exit(1);
        }
        const services = await registry.list();
        const builtins = ["list", "auth", "config", "completions", "alias", "history", "ask", "run", "flow"];
        if (services.some((s) => s.name === name) || builtins.includes(name)) {
          output.error(`Cannot create flow '${name}': conflicts with service or builtin command`);
          process.exit(1);
        }
        if (config.getAlias(name)) {
          output.error(`Cannot create flow '${name}': conflicts with existing alias`);
          process.exit(1);
        }
        await flow.addFlow(name, commands);
        output.success(`Created flow: ${name}`);
        console.log(`  ${dim("Commands:")} ${commands.join(` ${dim("\u2192")} `)}`);
        break;
      }
      case "remove":
      case "rm":
      case "delete": {
        const name = args[0];
        if (!name) {
          output.error("Usage: uni flow remove <name>");
          process.exit(1);
        }
        const removed = await flow.removeFlow(name);
        if (removed) {
          output.success(`Removed flow: ${name}`);
        } else {
          output.error(`Flow not found: ${name}`);
          process.exit(1);
        }
        break;
      }
      case "run": {
        const name = args[0];
        if (!name) {
          output.error("Usage: uni flow run <name> [args...]");
          process.exit(1);
        }
        const flowCommands = flow.getFlow(name);
        if (!flowCommands) {
          output.error(`Flow not found: ${name}`);
          process.exit(1);
        }
        const flowArgs = args.slice(1);
        const isDryRun = parsed2.flags["dry-run"] || parsed2.flags.n;
        const isParallel = parsed2.flags.parallel || parsed2.flags.p;
        const substituted = substituteArgs(flowCommands, flowArgs);
        const results = await runCommands(substituted, {
          dryRun: !!isDryRun,
          parallel: !!isParallel,
          json: parsed2.globalFlags.json
        });
        if (parsed2.globalFlags.json) {
          output.json({ results });
        }
        break;
      }
      default: {
        output.error(`Unknown flow command: ${subcommand}`);
        console.log(`
${bold("Usage:")}
  uni flow list                      List all flows
  uni flow add <name> <commands...>  Create a flow
  uni flow remove <name>             Remove a flow
  uni flow run <name> [args...]      Run a flow

${bold("Shorthand:")}
  uni <flowname> [args...]           Run a flow directly
`);
        process.exit(1);
      }
    }
  }
  async handleInstall(parsed2, output) {
    const name = parsed2.command;
    if (!name) {
      console.log(`
${bold("uni install")} - Install a service package

${bold("Usage:")}
  uni install <name>              Install a uni service

${bold("Examples:")}
  uni install linear              # \u2192 bun add @uni/service-linear
  uni install @other/some-plugin  # \u2192 bun add @other/some-plugin
  uni install uni-service-weather # \u2192 bun add uni-service-weather

${bold("Note:")}
  This is a convenience wrapper around 'bun add'.
  For simple names, it first tries @uni/service-<name>.
`);
      return;
    }
    const { spawn } = await import("child_process");
    let pkgName;
    if (name.startsWith("@") || name.startsWith("uni-service-")) {
      pkgName = name;
    } else {
      pkgName = `@uni/service-${name}`;
    }
    console.log(`${dim("\u2192")} bun add ${pkgName}`);
    const child = spawn("bun", ["add", pkgName], {
      stdio: "inherit",
      cwd: process.cwd()
    });
    await new Promise((resolve, reject) => {
      child.on("close", (code) => {
        if (code === 0) {
          registry.invalidate();
          output.success(`Installed ${pkgName}`);
          resolve();
        } else {
          if (!name.startsWith("@") && !name.startsWith("uni-service-")) {
            const fallbackPkg = `uni-service-${name}`;
            console.log(`
${dim("\u2192")} Trying ${fallbackPkg}...`);
            const fallbackChild = spawn("bun", ["add", fallbackPkg], {
              stdio: "inherit",
              cwd: process.cwd()
            });
            fallbackChild.on("close", (fallbackCode) => {
              if (fallbackCode === 0) {
                registry.invalidate();
                output.success(`Installed ${fallbackPkg}`);
                resolve();
              } else {
                output.error(`Could not find package: @uni/service-${name} or uni-service-${name}`);
                process.exit(1);
              }
            });
          } else {
            output.error(`Failed to install ${pkgName}`);
            process.exit(1);
          }
        }
      });
      child.on("error", (err) => {
        output.error(`Failed to run bun: ${err.message}`);
        reject(err);
      });
    });
  }
  async handleUninstall(parsed2, output) {
    const name = parsed2.command;
    if (!name) {
      console.log(`
${bold("uni uninstall")} - Uninstall a service package

${bold("Usage:")}
  uni uninstall <name>            Uninstall a uni service

${bold("Examples:")}
  uni uninstall linear            # \u2192 bun remove @uni/service-linear
  uni uninstall @other/plugin     # \u2192 bun remove @other/plugin
`);
      return;
    }
    const { spawn } = await import("child_process");
    let pkgName;
    if (name.startsWith("@") || name.startsWith("uni-service-")) {
      pkgName = name;
    } else {
      pkgName = `@uni/service-${name}`;
    }
    console.log(`${dim("\u2192")} bun remove ${pkgName}`);
    const child = spawn("bun", ["remove", pkgName], {
      stdio: "inherit",
      cwd: process.cwd()
    });
    await new Promise((resolve) => {
      child.on("close", (code) => {
        if (code === 0) {
          registry.invalidate();
          output.success(`Uninstalled ${pkgName}`);
        } else {
          output.error(`Failed to uninstall ${pkgName}`);
          process.exit(1);
        }
        resolve();
      });
      child.on("error", (err) => {
        output.error(`Failed to run bun: ${err.message}`);
        process.exit(1);
      });
    });
  }
}
var cli = new UniCLI;

// src/main.ts
cli.run(process.argv.slice(2)).catch((error2) => {
  console.error("Fatal error:", error2);
  process.exit(1);
});
